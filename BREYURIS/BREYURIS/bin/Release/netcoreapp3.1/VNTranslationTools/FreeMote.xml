<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FreeMote</name>
    </assembly>
    <members>
        <member name="T:FreeMote.Adler32">
            <summary>
            A class that can be used to compute the Adler-32 checksum of a data
            stream. An Adler-32 checksum is almost as reliable as a CRC-32 but
            can be computed much faster.
            <create>1.00 12/25/2009</create>
            <version>1.02 01/22/2018</version>
            <author>Singyuen Yip / Ulysses</author>
            </summary>
            http://blog.163.com/light_warm/blog/static/3168104201001195634824/
        </member>
        <member name="P:FreeMote.Adler32.Checksum">
            <summary>
            The checksum value.
            </summary>
        </member>
        <member name="M:FreeMote.Adler32.Update(System.IO.Stream)">
            <summary>
            Update checksum with stream.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:FreeMote.Adler32.Update(System.Int32)">
            <summary>
            Updates checksum with specified byte.
            </summary>
            <param name="b">an array of bytes</param>
        </member>
        <member name="M:FreeMote.Adler32.Update(System.Byte[])">
            <summary>
            Updates checksum with specified array of bytes.
            </summary>
            <param name="buf">the byte array to update the checksum with</param>
        </member>
        <member name="M:FreeMote.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Updates checksum with specified array of bytes.
            </summary>
            <param name="b">the byte array to update the checksum with</param>
            <param name="offset">the start offset of the data</param>
            <param name="length">the number of bytes to use for the update</param>
        </member>
        <member name="M:FreeMote.Adler32.Reset">
            <summary>
            Resets the checksum to its initial value.
            </summary>
        </member>
        <member name="M:FreeMote.Adler32.UpdateBytes(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Computing the checksum based on the Adler Algorithm.
            </summary>
            <param name="adler">the former checksum</param>
            <param name="buf">the byte array</param>
            <param name="index">the start offset of the data</param>
            <param name="len">the number of bytes to use for the update</param>
            <returns>the new checksum</returns>
        </member>
        <member name="M:FreeMote.Adler32.UpdateByte(System.Int64,System.Int32)">
            <summary>
            Update just one byte
            <para><b>since 1.01</b></para>
            </summary>
            <param name="adler">the former checksum</param>
            <param name="b">the byte in the integer</param>
            <returns>the new checksum</returns>
        </member>
        <member name="T:FreeMote.AstcHeader">
            <summary>
            AstcHeader - 16 bytes
            </summary>
        </member>
        <member name="T:FreeMote.BitmapHelper">
            <summary>
            Image loading toolset class which corrects the bug that prevents paletted PNG images with transparency from being loaded as paletted.
            </summary>
        </member>
        <member name="M:FreeMote.BitmapHelper.LoadBitmap(System.Byte[])">
            <summary>
            Loads an image, checks if it is a PNG containing palette transparency, and if so, ensures it loads correctly.
            The theory on the png internals can be found at http://www.libpng.org/pub/png/book/chapter08.html
            </summary>
            <param name="data">File data to load.</param>
            <returns>The loaded image.</returns>
        </member>
        <member name="M:FreeMote.BitmapHelper.FindChunk(System.Byte[],System.String)">
            <summary>
            Finds the start of a png chunk. This assumes the image is already identified as PNG.
            It does not go over the first 8 bytes, but starts at the start of the header chunk.
            </summary>
            <param name="data">The bytes of the png image.</param>
            <param name="chunkName">The name of the chunk to find.</param>
            <returns>The index of the start of the png chunk, or -1 if the chunk was not found.</returns>
        </member>
        <member name="M:FreeMote.BitmapHelper.CloneImage(System.Drawing.Bitmap)">
            <summary>
            Clones an image object to free it from any backing resources.
            Code taken from http://stackoverflow.com/a/3661892/ with some extra fixes.
            </summary>
            <param name="sourceImage">The image to clone.</param>
            <returns>The cloned image.</returns>
        </member>
        <member name="T:FreeMote.BTree">
            <summary>
            B Tree for string
            </summary>
            Who am I? Why I am here? What am I doing??? -Ulysses, 2017.7.7
            Rewrited from psbtools\pcc\psb_cc_btree by number201724(number201724@me.com).
        </member>
        <member name="T:FreeMote.BTree.BNode">
            <summary>
            Node for B Tree
            </summary>
        </member>
        <member name="M:FreeMote.BTree.Load(System.Collections.Generic.List{System.UInt32},System.Collections.Generic.List{System.UInt32},System.Collections.Generic.List{System.UInt32})">
            <summary>
            Load a B Tree
            </summary>
        </member>
        <member name="M:FreeMote.DxtUtil.Dxt1Decode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode a texture from DXT1 compression.
            </summary>
            <param name="data"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.DxtUtil.Dxt3Decode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode a texture from DXT3 compression.
            </summary>
            <param name="data"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.DxtUtil.Dxt5Decode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode a texture from DXT5 compression.
            </summary>
            <param name="data"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.DxtUtil.Dxt1Encode(System.Drawing.Bitmap)">
            <summary>
            Encode a bitmap to DXT1 texture.
            </summary>
            <param name="img"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.DxtUtil.Dxt3Encode(System.Drawing.Bitmap)">
            <summary>
            Encode a bitmap to DXT3 texture.
            </summary>
            <param name="img"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.DxtUtil.Dxt5Encode(System.Drawing.Bitmap)">
            <summary>
            Encode a bitmap to DXT5 texture.
            </summary>
            <param name="img"></param>
            <returns></returns>
        </member>
        <member name="T:FreeMote.MdfFile">
            <summary>
            MDF
            </summary> 
            Merged Data File
            Compressed PSB
        </member>
        <member name="F:FreeMote.MdfFile.Signature">
            <summary>
            MDF Signature
            </summary>
        </member>
        <member name="M:FreeMote.MdfFile.CompressPsbToMdfStream(System.IO.Stream,System.Boolean)">
            <summary>
            [RequireUsing]
            </summary>
            <param name="input"></param>
            <param name="fast"></param>
            <returns></returns>
        </member>
        <member name="T:FreeMote.PostProcessing">
            <summary>
            PS Related Post Process
            </summary>
        </member>
        <member name="M:FreeMote.PostProcessing.Swizzle(System.Drawing.Bitmap)">
            <summary>
            Unswizzle, this is much slower than <seealso cref="M:FreeMote.PostProcessing.UnswizzleTexture(System.Byte[],System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)"/>
            </summary>
            <param name="bmp"></param>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.GetPaletteBytes(System.Drawing.Imaging.ColorPalette,FreeMote.PsbPixelFormat)">
            <summary>
            Get RGBA bytes from palette
            </summary>
            <param name="palette"></param>
            <param name="palettePixelFormat"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.DefaultShellType(System.String)">
            <summary>
            Get shell type from suffix
            </summary>
            <param name="suffixString">e.g. xxx.xxx.m will return "MDF"</param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.DefaultExtension(FreeMote.PsbType)">
            <summary>
            Get <see cref="T:FreeMote.PsbType"/>'s default extension
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.UsePalette(FreeMote.PsbPixelFormat)">
            <summary>
            Whether the <see cref="T:FreeMote.PsbPixelFormat"/> use palette
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.UseTile(FreeMote.PsbSpec)">
            <summary>
            Whether the <see cref="T:FreeMote.PsbSpec"/> should use <see cref="M:FreeMote.PostProcessing.TileTexture(System.Byte[],System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)"/>
            </summary>
            <param name="spec"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.UseBigEndian(FreeMote.PsbSpec)">
            <summary>
            Whether the <see cref="T:FreeMote.PsbSpec"/> should use BigEndian
            </summary>
            <param name="spec"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.DefaultPixelFormat(FreeMote.PsbSpec)">
            <summary>
            Get <see cref="T:FreeMote.PsbSpec"/>'s default <see cref="T:FreeMote.PsbPixelFormat"/>
            </summary>
            <param name="spec"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.ToPsbPixelFormat(System.String,FreeMote.PsbSpec)">
            <summary>
            Get <see cref="T:FreeMote.PsbPixelFormat"/> from string and <see cref="T:FreeMote.PsbSpec"/>
            </summary>
            <param name="typeStr"></param>
            <param name="spec"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.ReadUInt32(FreeMote.PsbStreamContext,System.IO.BinaryReader)">
            <summary>
            Read a <see cref="T:System.UInt32"/> from <see cref="T:System.IO.BinaryReader"/>, and then encode using <see cref="T:FreeMote.PsbStreamContext"/>.
            </summary>
            <param name="context"></param>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.ReadBytes(FreeMote.PsbStreamContext,System.IO.BinaryReader,System.Int32)">
            <summary>
            Read bytes from <see cref="T:System.IO.BinaryReader"/>, and then encode using <see cref="T:FreeMote.PsbStreamContext"/>.
            </summary>
            <param name="context"></param>
            <param name="br"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.ReadUInt16(FreeMote.PsbStreamContext,System.IO.BinaryReader)">
            <summary>
            Read a <see cref="T:System.UInt16"/> from <see cref="T:System.IO.BinaryReader"/>, and then encode using <see cref="T:FreeMote.PsbStreamContext"/>.
            </summary>
            <param name="context"></param>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.Write(FreeMote.PsbStreamContext,System.UInt32,System.IO.BinaryWriter)">
            <summary>
            Encode a value and write using <see cref="T:System.IO.BinaryWriter"/>.
            </summary>
            <param name="context"></param>
            <param name="value"></param>
            <param name="bw"></param>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.Write(FreeMote.PsbStreamContext,System.UInt16,System.IO.BinaryWriter)">
            <summary>
            Encode a value and write using <see cref="T:System.IO.BinaryWriter"/>.
            </summary>
            <param name="context"></param>
            <param name="value"></param>
            <param name="bw"></param>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.WriteBE(System.IO.BinaryWriter,System.UInt32)">
            <summary>
            Big-Endian Write
            </summary>
            <param name="bw"></param>
            <param name="num"></param>
        </member>
        <member name="M:FreeMote.FreeMoteExtension.PrintInHex(System.Byte[])">
            <summary>
            Print byte array in Hex
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="T:FreeMote.RleCompress">
            <summary>
            RLE Compress
            <para>originally by number201724</para>
            </summary>
        </member>
        <member name="M:FreeMote.RleCompress.Decompress(System.IO.Stream,System.Int32,System.Int32)">
            <summary>
            RLE Decompress
            </summary>
            <param name="input"></param>
            <param name="actualSize"></param>
            <param name="align"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.RleCompress.CompressBound(System.IO.Stream,System.Int32,System.Byte@,System.Byte[]@)">
            <summary>
            Count equal patterns
            </summary>
            <param name="input"></param>
            <param name="align"></param>
            <param name="cmdByte"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.RleCompress.CompressBoundNp(System.IO.Stream,System.Int32,System.Byte@)">
            <summary>
            Count not equal patterns
            </summary>
            <param name="input"></param>
            <param name="align"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.RleCompress.Compress(System.IO.Stream,System.Int32)">
            <summary>
            RLE Compress
            </summary>
            <param name="input"></param>
            <param name="align"></param>
            <returns></returns>
        </member>
        <member name="T:FreeMote.Consts">
            <summary>
            Constants and Global Settings
            </summary>
        </member>
        <member name="F:FreeMote.Consts.MsManager">
            <summary>
            Recyclable MemoryStream Manager
            </summary>
        </member>
        <member name="F:FreeMote.Consts.ResourceNameDelimiter">
            <summary>
            delimiter for output texture filename
            </summary>
        </member>
        <member name="F:FreeMote.Consts.NumberStringPrefix">
            <summary>
            The string with this prefix will be convert to number when compile/decompile
            </summary>
        </member>
        <member name="F:FreeMote.Consts.ResourceIdentifier">
            <summary>
            The string with this prefix (with ID followed) will be convert to resource when compile/decompile
            </summary>
        </member>
        <member name="F:FreeMote.Consts.ExtraResourceIdentifier">
            <summary>
            The string with this prefix (with ID followed) will be convert to extra resource when compile/decompile
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Context_PsbShellType">
            <summary>
            (string)
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Context_CryptKey">
            <summary>
            (uint?)
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Context_PsbZlibFastCompress">
            <summary>
            (bool)
            <para>Fast: 0x9C BestCompression: 0xDA NoCompression/Low: 0x01</para>
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Context_ArchiveSource">
            <summary>
            (List) Archive sources
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Context_MdfKey">
            <summary>
            (string) MDF Seed (key + filename)
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Context_MdfMtKey">
            <summary>
            (string) MDF Key for MT19937
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Context_MdfKeyLength">
            <summary>
            (int) MDF Key length
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Context_UseFlattenArray">
            <summary>
            (bool) Whether to decode and encode FlattenArray in extra resources (false by default)
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Context_DisableCombinedImage">
            <summary>
            (bool) (for <see cref="F:FreeMote.PsbType.Tachie"/>) If set, always use chunk (piece) images to compile rather than use the combined one
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Key1">
            <summary>
            0x075BCD15
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Key2">
            <summary>
            0x159A55E5
            </summary>
        </member>
        <member name="F:FreeMote.Consts.Key3">
            <summary>
            0x1F123BB5
            </summary>
        </member>
        <member name="P:FreeMote.Consts.PsbDataStructureAlign">
            <summary>
            Perform 16 byte data align or not (when build)
            </summary>
        </member>
        <member name="P:FreeMote.Consts.InMemoryLoading">
            <summary>
            Take more memory when loading, but maybe faster
            </summary>
        </member>
        <member name="P:FreeMote.Consts.FastMode">
            <summary>
            Use more inferences to make loading fast, set to False when something is wrong
            </summary>
        </member>
        <member name="P:FreeMote.Consts.StrictMode">
            <summary>
            Use more strict checks and if conditions are not met, just terminate
            </summary>
        </member>
        <member name="P:FreeMote.Consts.JsonUseHexNumber">
            <summary>
            Use hex numbers in json to keep all float numbers correct
            </summary>
        </member>
        <member name="P:FreeMote.Consts.JsonArrayCollapse">
            <summary>
            Collapse arrays in json
            </summary>
        </member>
        <member name="P:FreeMote.Consts.JsonUseDoubleOnly">
            <summary>
            Always use double instead of float
            </summary>
        </member>
        <member name="P:FreeMote.Consts.PsbObjectOrderByKey">
            <summary>
            Whether to sort the object order by key when build PSB
            </summary>
        </member>
        <member name="P:FreeMote.Consts.FlattenArrayByDefault">
            <summary>
            Always consider ExtraResource as FlattenArray of float unless it's not 4-bytes aligned
            </summary>
        </member>
        <member name="P:FreeMote.Consts.PaletteMerge">
            <summary>
            (not implemented yet) Use Palette Merge will increase compile time but cut output size (only when using CI* images)
            </summary>
        </member>
        <member name="P:FreeMote.Consts.GeneratePalette">
            <summary>
            Allows you to edit CI* images by re-generate the palette for each bppIndexed image (will increase size), otherwise you should not change those images
            </summary>
        </member>
        <member name="P:FreeMote.Consts.PreferManaged">
            <summary>
            Use managed code rather than external/native if possible
            </summary>
        </member>
        <member name="P:FreeMote.Consts.CombineAudioChannels">
            <summary>
            (not implemented yet) If the audio have 2 channels, try to combine them when output wave
            </summary>
        </member>
        <member name="T:FreeMote.PsbCombineMethod">
            <summary>
            PSB.Combine(PSB)
            </summary>
        </member>
        <member name="F:FreeMote.PsbCombineMethod.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:FreeMote.PsbCombineMethod.All">
            <summary>
            Merge everything
            </summary>
        </member>
        <member name="F:FreeMote.PsbCombineMethod.Objects">
            <summary>
            Only merge objects
            </summary>
        </member>
        <member name="T:FreeMote.PsbType">
            <summary>
            PSB Type
            </summary>
        </member>
        <member name="F:FreeMote.PsbType.PSB">
            <summary>
            Unknown type PSB
            </summary>
        </member>
        <member name="F:FreeMote.PsbType.Pimg">
            <summary>
            Images (pimg, dpak)
            </summary>
        </member>
        <member name="F:FreeMote.PsbType.Scn">
            <summary>
            Script (scn)
            </summary>
            TODO: KS decompiler?
        </member>
        <member name="F:FreeMote.PsbType.Mmo">
            <summary>
            EMT project - M2 MOtion (mmo, emtproj)
            </summary>
        </member>
        <member name="F:FreeMote.PsbType.Tachie">
            <summary>
            Images with Layouts (used in PS4, PSV)
            </summary>
        </member>
        <member name="F:FreeMote.PsbType.ArchiveInfo">
            <summary>
            MDF Archive Index (_info.psb.m)
            </summary>
        </member>
        <member name="F:FreeMote.PsbType.BmpFont">
            <summary>
            BMP Font (e.g. textfont24)
            </summary>
        </member>
        <member name="F:FreeMote.PsbType.Motion">
            <summary>
            EMT
            </summary>
        </member>
        <member name="F:FreeMote.PsbType.SoundArchive">
            <summary>
            Sound Archive
            </summary>
        </member>
        <member name="T:FreeMote.PsbSpec">
            <summary>
            EMT PSB Platform
            </summary>
        </member>
        <member name="F:FreeMote.PsbSpec.none">
            <summary>
            Do not have spec
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:FreeMote.PsbSpec.common" -->
        <member name="F:FreeMote.PsbSpec.krkr">
            <summary>
            Kirikiri
            </summary>
        </member>
        <member name="F:FreeMote.PsbSpec.win">
            <summary>
            DirectX
            </summary>
        </member>
        <member name="F:FreeMote.PsbSpec.ems">
            <summary>
            WebGL
            </summary>
        </member>
        <member name="F:FreeMote.PsbSpec.vita">
            <summary>
            PS Vita
            </summary>
        </member>
        <member name="F:FreeMote.PsbSpec.ps4">
            <summary>
            PS4
            </summary>
        </member>
        <member name="F:FreeMote.PsbSpec.nx">
            <summary>
            NSwitch
            </summary>
        </member>
        <member name="T:FreeMote.PsbExtractOption">
            <summary>
            How to handle resource when decompiling
            </summary>
        </member>
        <member name="F:FreeMote.PsbExtractOption.Original">
            <summary>
            Keep original
            </summary>
        </member>
        <member name="F:FreeMote.PsbExtractOption.Extract">
            <summary>
            Try to convert to common format
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.LeRGBA8">
            <summary>
            Little Endian RGBA8 (plat: win)
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.BeRGBA8">
            <summary>
            Big Endian RGBA8 (plat: common)
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.LeRGBA4444">
            <summary>
            Little Endian RGBA4444 (plat: win)
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.BeRGBA4444">
            <summary>
            Big Endian RGBA4444 (plat: common)
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.RGBA5650">
            <summary>
            RGBA5650
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.A8L8">
            <summary>
            A8L8
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.L8">
            <summary>
            L8
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.A8">
            <summary>
            A8
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.RGBA8_SW">
            <summary>
            BeRGBA8_SW (Swizzle) for vita
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.TileRGBA8_SW">
            <summary>
            LeRGBA8_SW (Tile) for PS4
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.LeRGBA4444_SW">
            <summary>
            Little Endian RGBA4444 with Swizzle for vita
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.RGBA5650_SW">
            <summary>
            RGBA5650 with Swizzle for vita
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.TileRGBA5650_SW">
            <summary>
            RGBA5650 with Tile for PS4
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.A8L8_SW">
            <summary>
            A8L8 with Swizzle for vita
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.TileA8L8_SW">
            <summary>
            A8L8_SW (Tile) for PS4
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.L8_SW">
            <summary>
            L8 with Swizzle for vita
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.TileL8_SW">
            <summary>
            L8_SW (Tile) for PS4
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.A8_SW">
            <summary>
            A8_SW (Swizzle)
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.TileA8_SW">
            <summary>
            A8_SW (Tile) for PS4
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.CI8_SW">
            <summary>
            CI8 (C8) with Swizzle for vita
            </summary>
            REF: http://wiki.tockdom.com/wiki/Image_Formats#C8_.28CI8.29
        </member>
        <member name="F:FreeMote.PsbPixelFormat.CI4_SW">
            <summary>
            CI4 with Swizzle for vita
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.DXT5">
            <summary>
            Big Endian DXT5
            </summary>
        </member>
        <member name="F:FreeMote.PsbPixelFormat.ASTC_8BPP">
            <summary>
            ASTC with block 4x4 for nx
            </summary>
        </member>
        <member name="F:FreeMote.PsbAudioPan.Mono">
            <summary>
            1 Channel
            </summary>
        </member>
        <member name="F:FreeMote.PsbAudioPan.Left">
            <summary>
            Left Channel
            </summary>
        </member>
        <member name="F:FreeMote.PsbAudioPan.Right">
            <summary>
            Right Channel
            </summary>
        </member>
        <member name="F:FreeMote.PsbAudioPan.LeftRight">
            <summary>
            2 channels, first is Left, second is Right
            </summary>
        </member>
        <member name="F:FreeMote.PsbAudioPan.Stereo">
            <summary>
            Stereo (in 1 Channel)
            </summary>
        </member>
        <member name="F:FreeMote.PsbAudioPan.Multiple">
            <summary>
            Multiple Channels (2+)
            </summary>
        </member>
        <member name="F:FreeMote.PsbAudioPan.Intro">
            <summary>
            Intro (for Loop)
            </summary>
        </member>
        <member name="F:FreeMote.PsbAudioPan.Body">
            <summary>
            Body (for Loop)
            </summary>
        </member>
        <member name="F:FreeMote.PsbAudioPan.IntroBody">
            <summary>
            Intro + Body (NX OPUS)
            </summary>
        </member>
        <member name="F:FreeMote.EncodePosition.Auto">
            <summary>
            Automata
            <para>if encrypt v3-V4, will only encrypt header.</para>
            <para>if encrypt v2, will only encrypt body(strings).</para>
            <para>if decrypt, clean header and body both.</para>
            </summary>
        </member>
        <member name="M:FreeMote.PsbFile.ParseHeader">
            <summary>
            Parse PSB Header
            </summary>
        </member>
        <member name="M:FreeMote.PsbFile.ParseHeader(System.UInt32)">
            <summary>
            Parse PSB encrypted header with key
            </summary>
        </member>
        <member name="M:FreeMote.PsbFile.TestHeaderEncrypted">
            <summary>
            Try to test if header is encrypted actually, based on assumption. Only work for E-mote PSB
            </summary>
            <returns>true if header seems to be encrypted</returns>
        </member>
        <member name="M:FreeMote.PsbFile.TestBodyEncrypted">
            <summary>
            Try to test if body is encrypted actually, based on assumption. Only work for E-mote PSB
            </summary>
            <returns>true if body seems to be encrypted</returns>
        </member>
        <member name="M:FreeMote.PsbFile.WriteDecryptPartialHeader(System.IO.BinaryReader,System.IO.BinaryWriter,FreeMote.PsbStreamContext,FreeMote.PsbHeader)">
            <summary>
            Assume header is encrypted
            </summary>
            <param name="br"></param>
            <param name="bw"></param>
            <param name="context"></param>
            <param name="header"></param>
        </member>
        <member name="M:FreeMote.PsbFile.WriteEncryptPartialHeader(System.IO.BinaryReader,System.IO.BinaryWriter,FreeMote.PsbStreamContext,FreeMote.PsbHeader)">
            <summary>
            Assume header is clean
            </summary>
            <param name="br"></param>
            <param name="bw"></param>
            <param name="context"></param>
            <param name="header"></param>
        </member>
        <member name="M:FreeMote.PsbFile.EncodeToFile(System.UInt32,System.String,FreeMote.EncodeMode,FreeMote.EncodePosition)">
            <summary>
            Encrypt or decrypt PSB and write to a file
            </summary>
            <param name="key"></param>
            <param name="savePath"></param>
            <param name="mode"></param>
            <param name="position"></param>
        </member>
        <member name="M:FreeMote.PsbFile.Transfer(System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Transfer from an old key to a new key
            </summary>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="inputBytes"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.PsbFile.EncodeToBytes(System.UInt32,System.Byte[],FreeMote.EncodeMode,FreeMote.EncodePosition)">
            <summary>
            Encode a psb byte array manually
            </summary>
            <param name="key"></param>
            <param name="inputBytes"></param>
            <param name="mode"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.PsbFile.Encode(System.UInt32,FreeMote.EncodeMode,FreeMote.EncodePosition,System.IO.Stream,System.IO.Stream)">
            <summary>
            Encode (Encrypt/Decrypt) PSB file
            </summary>
            <param name="key"></param>
            <param name="mode"></param>
            <param name="position"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns>Unencrypted Header for reference. Usually you shouldn't use it.</returns>
        </member>
        <member name="M:FreeMote.PsbFile.CheckSignature(System.IO.Stream)">
            <summary>
            Test if the first 4 bytes belong to a correct PSB header
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:FreeMote.PsbHeader">
            <summary>
            PSB Header
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.MAX_HEADER_LENGTH">
            <summary>
            Max length of header AFAIK. Need to be fixed if there are longer headers exist.
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.HeaderEncrypt">
            <summary>
            If 1, the header seems encrypted, which add more difficulty to us
            <para>But doesn't really matters since usually it's always encrypted in v3+</para>
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.HeaderLength">
            <summary>
            Header Length
            <para>Usually same as <see cref="F:FreeMote.PsbHeader.OffsetNames"/></para>
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.OffsetNames">
            <summary>
            Offset of Names
            <para>Usually the beginning of encryption in v2</para>
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.OffsetChunkOffsets">
            <summary>
            ResOffTable
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.OffsetChunkData">
            <summary>
            Offset of Chunk Data (Image)
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.OffsetEntries">
            <summary>
            Entry Offset
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.Checksum">
            <summary>
            [v3] Adler32 Checksum for header
            <para>Not always checked in v3. Sadly, it's always checked from v4, so we have to handle it.</para>
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.OffsetExtraChunkOffsets">
            <summary>
            [v4] Extra chunk offsets
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.OffsetExtraChunkLengths">
            <summary>
            [v4] Extra chunk lengths
            </summary>
        </member>
        <member name="F:FreeMote.PsbHeader.OffsetExtraChunkData">
            <summary>
            [v4] 
            <para>If there are no data, same as <see cref="F:FreeMote.PsbHeader.OffsetChunkOffsets"/></para>
            </summary>
        </member>
        <member name="M:FreeMote.PsbHeader.UpdateChecksum">
            <summary>
            Update Checksum
            </summary>
            <returns>Current Checksum</returns>
        </member>
        <member name="M:FreeMote.PsbHeader.GetHeaderLength">
            <summary>
            Get Header Length based on Version
            </summary>
            <returns></returns>
        </member>
        <member name="M:FreeMote.PsbHeader.SwitchVersion(System.UInt16,System.Boolean)">
            <summary>
            Change version for Header
            </summary>
            <param name="version"></param>
            <param name="offsetFields">if true, offset all fields</param>
        </member>
        <member name="P:FreeMote.PsbHeader.IsHeaderEncrypted">
            <summary>
            Similar as <see cref="M:FreeMote.PsbFile.TestHeaderEncrypted"/> but not based on file.
            </summary>
        </member>
        <member name="T:FreeMote.PsbStreamContext">
            <summary>
            PSB Stream Cipher Context (XorShift128)
            </summary>
        </member>
        <member name="P:FreeMote.PsbStreamContext.Key1">
            <summary>
            Key 1
            <para>Usually you shouldn't modify it.</para>
            </summary>
        </member>
        <member name="P:FreeMote.PsbStreamContext.Key2">
            <summary>
            Key 2
            <para>Usually you shouldn't modify it.</para>
            </summary>
        </member>
        <member name="P:FreeMote.PsbStreamContext.Key3">
            <summary>
            Key 3
            <para>Usually you shouldn't modify it.</para>
            </summary>
        </member>
        <member name="P:FreeMote.PsbStreamContext.Key4">
            <summary>
            Key 4
            <para>This is the key which differs among versions.</para>
            </summary>
        </member>
        <member name="P:FreeMote.PsbStreamContext.CurrentKey">
            <summary>
            Current Key
            </summary>
        </member>
        <member name="P:FreeMote.PsbStreamContext.Round">
            <summary>
            Stream Round
            </summary>
        </member>
        <member name="P:FreeMote.PsbStreamContext.ByteCount">
            <summary>
            Round Count in byte
            </summary>
        </member>
        <member name="M:FreeMote.PsbStreamContext.Encode(System.Byte[]@)">
            <summary>
            Encode bytes using stream cipher.
            <para>Every time called, the key might be modified.</para>
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.PsbStreamContext.Encode(System.Byte[])">
            <summary>
            Encode bytes using stream cipher.
            <para>Every time called, the key might be modified.</para>
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.PsbStreamContext.FastForward(System.UInt32)">
            <summary>
            Skip some bytes
            </summary>
            <param name="byteLength"></param>
        </member>
        <member name="M:FreeMote.PsbStreamContext.NextRound">
            <summary>
            Skip to next round
            </summary>
        </member>
        <member name="T:FreeMote.RL">
            <summary>
            Resource Loader
            </summary>
        </member>
        <member name="M:FreeMote.RL.ConvertToImage(System.Byte[],System.Int32,System.Int32,FreeMote.PsbPixelFormat)">
            <summary>
            Convert a special format image to common image for extract
            </summary>
            <param name="data"></param>
            <param name="height"></param>
            <param name="width"></param>
            <param name="colorFormat"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.RL.PixelBytesFromImage(System.Drawing.Bitmap,FreeMote.PsbPixelFormat)">
            <summary>
            Convert a common image to special format image for build
            </summary>
            <param name="bmp"></param>
            <param name="pixelFormat"></param>
            <returns></returns>
        </member>
        <member name="M:FreeMote.RL.Switch_0_2(System.Byte[]@)">
            <summary>
            BGRA(LE ARGB) -> RGBA(BE RGBA)  (switch B &amp; R)
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:FreeMote.RL.Argb2Rgba(System.Byte[]@,System.Boolean)">
            <summary>
            RGBA(BE) -> ARGB(LE BGRA) (switch A)
            </summary>
            <param name="bytes"></param>
            <param name="reverse"></param>
        </member>
        <member name="M:FreeMote.RL.Argb428(System.Byte[],System.Boolean)">
            <summary>
            RGBA4444 &amp; RGBA8 conversion
            </summary>
            <param name="bytes"></param>
            <param name="extend">true: 4 to 8; false: 8 to 4</param>
            Shibuya Scramble!
        </member>
        <member name="M:FreeMote.ZlibCompress.DecompressToStream(System.IO.Stream,System.Int32)">
            <summary>
            [RequireUsing]
            </summary>
            <param name="input"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathNetCore.GetRelativePath(System.String,System.String)">
            <summary>
            Create a relative path from one path to another. Paths will be resolved before calculating the difference.
            Default path comparison for the active platform will be used (OrdinalIgnoreCase for Windows or Mac, Ordinal for Unix).
            </summary>
            <param name="relativeTo">The source path the output should be relative to. This path is always considered to be a directory.</param>
            <param name="path">The destination path.</param>
            <returns>The relative path or <paramref name="path"/> if the paths don't share the same root.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="relativeTo"/> or <paramref name="path"/> is <c>null</c> or an empty string.</exception>
        </member>
        <member name="P:System.IO.PathNetCore.StringComparison">
            <summary>Returns a comparison that can be used to compare file and directory names for equality.</summary>
        </member>
        <member name="T:System.IO.PathInternalNetCore">
            <summary>Contains internal path helpers that are shared between many projects.</summary>
        </member>
        <member name="M:System.IO.PathInternalNetCore.AreRootsEqual(System.String,System.String,System.StringComparison)">
            <summary>
            Returns true if the two paths have the same root
            </summary>
        </member>
        <member name="M:System.IO.PathInternalNetCore.GetRootLength(System.String)">
            <summary>
            Gets the length of the root of the path (drive, share, etc.).
            </summary>
        </member>
        <member name="M:System.IO.PathInternalNetCore.IsDirectorySeparator(System.Char)">
            <summary>
            True if the given character is a directory separator.
            </summary>
        </member>
        <member name="M:System.IO.PathInternalNetCore.GetCommonPathLength(System.String,System.String,System.Boolean)">
            <summary>
            Get the common path length from the start of the string.
            </summary>
        </member>
        <member name="M:System.IO.PathInternalNetCore.EqualStartingCharacterCount(System.String,System.String,System.Boolean)">
            <summary>
            Gets the count of common characters from the left optionally ignoring case
            </summary>
        </member>
        <member name="M:System.IO.PathInternalNetCore.EndsInDirectorySeparator(System.String)">
            <summary>
            Returns true if the path ends in a directory separator.
            </summary>
        </member>
    </members>
</doc>
